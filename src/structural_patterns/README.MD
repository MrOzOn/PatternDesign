# [Адаптер (Adapter)](./adapter/main.kt)

Это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Преобразует интерфейс одного класса в другой интерфейс, на который рассчитаны клиенты.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Иногда возможно создать даже _двухсторонний_ адаптер, который работал бы в обе стороны.

**Адаптер объектов**
Эта реализация использует агрегацию: объект адаптера «оборачивает», то есть содержит ссылку на служебный объект. Такой подход работает во всех языках программирования.

**Адаптер классов**
Эта реализация базируется на наследовании: адаптер наследует оба интерфейса одновременно. Такой подход возможен только в языках, поддерживающих множественное наследование, например, C++.

## Другое название
Обертка (Wrapper)

## Применимость

- вы хотите использовать существующий класс, но его интерфейс не соответствует вашим потребностям
- требуется создать повторно используемый класс, который должен взаимодействовать с заранее неизвестными или не связанными с ним классами, имеющими несовместимые интерфейсы
- (**_только для адаптера объектов!_**) нужно использовать несколько существующих подклассов, но непрактично адаптировать их интерфейсы путем порождения новых подклассов от каждого. В этом случае адаптер объектов может приспосабливать интерфейс их общего родительского класса

## Отношения

Клиенты вызывают операции экземпляра адаптера Adapter. В свою очередь адаптер вызывает операции адаптируемого объекта или класса Adaptee, который и выполняет запрос.

## Результаты

Адаптеры объектов и классов обладают разными достоинствами и недостатками.

**Адаптер объектов**
- позволяет одному адаптеру (Adapter) работать со многим адаптируемыми объектами (Adaptee), то есть с самим Adaptee и его подклассами (если таковые имеются). Адаптер может добавить новую функциональность сразу всем адаптируемым объектам
- затрудняет замещение операций класса Adaptee. Для этого потребуется породить от Adaptee подкласс и заставить Adapter ссылаться на этот подкласс, а не на сам Adaptee

**Адаптер классов**
- адаптирует адаптируемый класс (Adaptee) к целе (Target), перепоручая действия конкретному классу Adaptee. Поэтому данный паттерн не будет работать, если мы захотим одновременно адаптировать класс и его подклассы
- позволяет адаптеру (Adapter) заместить некоторые операции адаптируемого класса Adaptee, так как Adapter есть не что иное, как подкласс Adaptee
- вводит только один новый объект. Чтобы добраться до адаптируемого класса, не нужно никакого дополнительного обращения по указателю

# [Мост (Bridge)](./bridge/main.kt)

Это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

## Другое название
Описатель/Тело (Handle/Body)

## Применимость

- требуется избежать постоянной привязки абстракции к реализации
- и абстракции, и реализации должны расширяться новыми подклассами
- изменения в реализации абстракции не должны отражаться на клиентах
- число классов стремительно разрастается

## Отношения

Объект абстракции перенаправляет запросы клиента своему объекту реализации.

## Результаты

- отделение реализации от интерфейса
- повышение степени расширяемости
- сокрытие деталей реализации от клиентов

# [Компоновщик (Composite)](./composite/main.kt)

Это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

## Применимость

- требуется представить иерархию объектов вида «часть — целое»
- клиенты должны по единым правилам работать с составными и индивидуальными объектами

## Отношения

Клиенты используют интерфейс класса Graphic для взаимодействия с объектами в составной структуре. Если получателем запроса является листовый объект (Dot, Circle), то он и обрабатывает запрос. Когда же получателем является составной объект CompoundGraphic, то обычно он перенаправляет запрос своим потомкам — возможно, с выполнением некоторых дополнительных операций до или после перенаправления.

## Результаты

- определяет иерархии классов, состоящие из примитивных и составных объектов
- упрощает архитектуру клиента
- облегчает добавление новых видов компонентов. Новые подклассы классов CompoundGraphic или Dot, Circle будут автоматически работать с уже существующими структурами и клиентским кодом.
- способствует созданию общего дизайна

**_Важно_**

Иногда бывает нужно, чтобы составной объект мог включать только определенные виды компонентов. Паттерн компоновщик не позволяет воспользоваться для реализации таких ограничений статической системой типов. Вместо этого приходится проводить проверки во время выполнения.