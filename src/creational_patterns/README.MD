#Абстрактная фабрика (Abstract Factory)

Это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

Другими словами, предоставляет интерфейс для создания семейств взаимосвязанных объектов, не специфицируя их конкретных классов.

## Применимость

- система не должна зависеть от того, как создаются, компонуются и представляются входящие в нее объекты
- система должна настраиваться одним из семейств объектов
- входящие в семейство взаимосвязанные объекты спроектированы для совместной работы, и вы должны обеспечить выполнение этого ограничения
- вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию

## Отношения

- обычно во время выполнения создается единственный экземпляр класса конкретной реализации фабрики (**MacFactory**)
- абстрактная фабрика передоверяет создание объектов-продуктов своему подклассу (**MacFactory**)

## Результаты

- изолируются конкретные классы, клиент не знает подробностей реализации классов, а взаимодействуют только через их абстрактные интерфейсы
- упрощается замена семейств продуктов
- гарантируется сочетаемость продуктов
- НЕ УПРОЩАЕТ задачу поддержки нового вида продукта, так как необходимо расширить интерфейс абстрактной фабрики, НО и всех его подклассов

#Строитель (Builder)

Это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов

## Применимость

- алгоритм сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой
- процесс конструирования должен обеспечивать различные представления конструируемого объекта

## Отношения

- клиент создает объект-распорядитель Director и настраивает его нужным объектом-строителем Builder
- распорядитель уведомляет строителя о том, что нужно построить очередную часть продукта
- строитель обрабатывает запросы распорядителя и добавляет новые части к продукту
- клиент забирает продукт у строителя

## Результаты

- позволяет изменять внутреннее представление продукта
- изолирует код, реализующий̆ конструирование и представление
- предоставляет более точный̆ контроль над процессом конструирования

#Фабричный метод (Factory Method)

Это паттерн, порождающий̆ классы.

Это порождающий паттерн, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

## Применимость

- классу заранее неизвестно, объекты каких классов ему нужно создавать
- класс спроектирован так, чтобы объекты, которые он создает, определялись подклассами
- класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и вам нужно локализовать информацию о том, какой̆ класс принимает эти обязанности на себя

## Отношения

Создатель полагается на свои подклассы в определении фабричного метода, который̆ будет возвращать экземпляр подходящего конкретного продукта.

## Результаты

Фабричные методы избавляют проектировщика от необходимости встраивать в код зависящие от приложения классы. Код имеет дело только с интерфейсом класса, поэтому он может работать с любыми определенными пользователями классами конкретных продуктов.

#Прототип (Prototype)

Это порождающий паттерн, который задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа

## Применимость

Система не должна зависеть от того, как в ней создаются, компонуются и представляются продукты; _кроме того_:
- классы для создания экземпляров определяются во время выполнения, например с помощью динамической загрузки; _или_
- для того чтобы избежать построения иерархий классов или фабрик, па- раллельных иерархии классов продуктов; _или_
- экземпляры класса могут находиться в одном из не очень большого числа различных состояний.

## Отношения

Клиент обращается к прототипу, чтобы тот создал свою копию.

## Результаты

У прототипа те же самые результаты, что у **абстрактной фабрики** и **строителя**: он скрывает от клиента конкретные классы продуктов, уменьшая тем самым число известных клиенту имен. Кроме того, все эти паттерны позволяют клиентам работать с классами, специфичными для приложения, без модификаций.
Дополнительные преимущества паттерна:
- добавление и удаление продуктов во время выполнения
- определение новых объектов путем изменения значений
- уменьшение числа подклассов
- динамическая настройка конфигурации приложения классами

#Одиночка (Singleton)

Это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

## Применимость

- должен существовать ровно один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа
- единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность работать с расширенным экземпляром без модификации своего кода

## Отношения

Клиенты получают доступ к экземпляру класса Singleton только через его операцию **getInstance**.

## Результаты

- контролируемый доступ к единственному экземпляру
- возможность уточнения операций и представления. От класса Singleton можно порождать подклассы, а приложение легко настраивается экземпляром расширенного класса.

